"""
피보나치 수열의 점화식
a_n = a_(n-1)+a_(n-2) , a_1=1,a_2=1
"""
"""
def fibo(x):
    if x==1 or x==2:
        return 1
    return fibo(x-1)+fibo(x-2)
x=int(input())
print(fibo(x))
"""
"""
재귀함수로 작성시 f(6)을 계산하기 위해 f(2)가 반복됨

피보나치수열의 복잡도는 O(2^n)
f(30)을 계산하기 위해 10억가량의 연산 필요
"""

"""
다이나믹 프로그래밍의 사용 조건
1. 최적 부분 구조 - 큰 문제를 작은 문제로 나눌 수 있다.
2. 중복되는 부분 문제 - 동일한 작은 문제를 반복적으로 해결한다.
피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족한다

상향식과 하향식이 존재
"""

"""
하향식
memoization (메모이제이션)
한번 계산한 결과를 메모리 공간에 메모하는 기법
같은 문제를 다시 호출하면 메모한 결과를 그대로 가져온다.
값을 기록해 놓는다는 점에서 캐싱이라고도 한다
제귀적인 방식을 사용한다
"""
"""
상향식
아래쪽에서부터 작은 문제를 해결해 나가면서 먼저 계산한 문제의 결과를 저장
주로 반복문을 사용한다.
전형적인 다이나믹프로그래밍 현태는 상향식
"""

#하향식 다이나믹 프로그래밍 피보나치 수열
dp = [0]*100
def fibo(x):
    if x==1 or x==2:
        return 1
    if dp[x]!=0:
        return dp[x]
    dp[x]=fibo(x-1)+fibo(x-2)
    return dp[x]
print(fibo(99))

#상향식 다이나믹 프로그래밍 피보나치 수열
n = 99
d = [0] * 100
d[2],d[1]=1,1
for i in range(3, n+1):
    d[i]=d[i-1]+d[i-2]
print(d[n])